# Path from Root to Node.
## Problem Statement
Given a Binary Tree, return the path from the root to a specified node.

### Constraints
- Given node is guaranteed to be present in the tree.
- Node values are unique.

## Approach (DFS)
- We can use a depth-first search (DFS) approach to traverse the tree and find the path to the specified node.
- We will maintain a list to store the current path from the root to the current node.
- When we reach the specified node, we will return the path.
```go
func findPath(root *TreeNode, target int, path *[]int) bool {
	if root == nil {
		return false
	}

	if root.Val == target {
		*path = append([]int{root.Val}, *path...) 
		return true
	}

	if findPath(root.Left, target, path) || findPath(root.Right, target, path) {
		*path = append([]int{root.Val}, *path...)
		return true
	}

	return false
}

func rootToNodePath(root *TreeNode, target int) []int {
	path := []int{}
	if findPath(root, target, &path) {
		return path
	}
	return nil // Return nil if the target is not found 
}
```

## Complexity Analysis
- **Time Complexity**: O(n), where n is the number of nodes in the binary tree. We may visit each node once.
- **Space Complexity**: O(h), where h is the height of the tree. This is due to the recursive stack space used during the traversal.

## Example Usage
```go
func main() {
    root := &TreeNode{
		Val: 1,
		Left: &TreeNode{
			Val: 2,
			Left: &TreeNode{
				Val: 4,
			},
			Right: &TreeNode{
				Val: 5,
				Left: &TreeNode{
					Val: 6,
				},
				Right: &TreeNode{
					Val: 7,	
				},
			},
		},
		Right: &TreeNode{
			Val: 3,
		},
	}

	target := 7
	path := rootToNodePath(root, target)
	fmt.Println("Path from root to node", target, ":", path) // [1, 2, 5, 7]
}
```